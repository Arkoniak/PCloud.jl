<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage examples · PCloud.jl</title><link rel="canonical" href="https://Arkoniak.github.io/PCloud.jl/examples/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PCloud.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../reference/">Reference API</a></li><li class="is-active"><a class="tocitem" href>Usage examples</a><ul class="internal"><li><a class="tocitem" href="#Uploading-and-downloading-CSV-1"><span>Uploading and downloading CSV</span></a></li><li><a class="tocitem" href="#Uploading-generated-image-1"><span>Uploading generated image</span></a></li><li><a class="tocitem" href="#Project-Gutenberg-and-downloadfile-1"><span>Project Gutenberg and <code>downloadfile</code></span></a></li></ul></li><li><a class="tocitem" href="../developers/">Deveopers guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Arkoniak/PCloud.jl/blob/master/docs/src/examples.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples-of-usage-1"><a class="docs-heading-anchor" href="#Examples-of-usage-1">Examples of usage</a><a class="docs-heading-anchor-permalink" href="#Examples-of-usage-1" title="Permalink"></a></h1><p>Here I collected different snippets, which can help in building fast and simple data pipelines with the usage of <code>PCloud.jl</code>. These snippets are not the best possible ways to solve problems, but they can be used as a starting point and also I&#39;ve tried to show, how to apply various Julia techniques such as broadcasting and anonymous functions together with <code>pCloud</code> to achieve goals without to much efforts.</p><h2 id="Uploading-and-downloading-CSV-1"><a class="docs-heading-anchor" href="#Uploading-and-downloading-CSV-1">Uploading and downloading CSV</a><a class="docs-heading-anchor-permalink" href="#Uploading-and-downloading-CSV-1" title="Permalink"></a></h2><p>CSV is rather common format for storing data, and <a href="https://github.com/JuliaData/CSV.jl">CSV.jl</a> provides convenient function <code>CSV.write</code> which can store data in <code>IOBuffer</code> which in turn can be uploaded to <code>pCloud</code>.</p><p>Let&#39;s create <code>DataFrame</code></p><pre><code class="language-julia">using CSV
using DataFrames
using Random

df = DataFrame(x = rand(10), y = rand(1:10, 10), z = [randstring(5) for _ in 1:10])
# 10×3 DataFrame
# │ Row │ x         │ y     │ z      │
# │     │ Float64   │ Int64 │ String │
# ├─────┼───────────┼───────┼────────┤
# │ 1   │ 0.0756344 │ 6     │ H3BIk  │
# │ 2   │ 0.396882  │ 5     │ Rv2SB  │
# │ 3   │ 0.797529  │ 5     │ M61Hw  │
# │ 4   │ 0.856915  │ 5     │ jLc7K  │
# │ 5   │ 0.0120147 │ 1     │ HgZMA  │
# │ 6   │ 0.493593  │ 3     │ ENfu3  │
# │ 7   │ 0.27618   │ 2     │ MIU5B  │
# │ 8   │ 0.492329  │ 10    │ QflU7  │
# │ 9   │ 0.398613  │ 10    │ 4XioP  │
# │ 10  │ 0.40273   │ 10    │ PQs14  │</code></pre><p>To store this dataframe in <code>pCloud</code> we write it&#39;s contents to <code>IOBuffer</code> and upload resulting buffer to <code>pCloud</code> with the help of <code>uploadfile</code> function</p><pre><code class="language-julia">using PCloud
using PCloud: uploadfile, getfilelink

token = # HERE SHOULD BE YOUR TOKEN
client = PCloudClient(auth_token = token)

buffer = CSV.write(IOBuffer, df)
res = uploadfile(client, files = &quot;data.csv&quot; =&gt; buf)</code></pre><p>Returned reponse <code>res</code> contains necessary information about resulting file. And to get it back we can use <code>getfilelink</code></p><pre><code class="language-julia">using UrlDownload
using Underscores

df2 = @_ getfilelink(client, fileid = first(res.fileids)) |&gt;
    urldownload(&quot;https://&quot; * first(__.hosts) * __.path) |&gt; DataFrame
# 10×3 DataFrame
# │ Row │ x         │ y     │ z      │
# │     │ Float64   │ Int64 │ String │
# ├─────┼───────────┼───────┼────────┤
# │ 1   │ 0.0756344 │ 6     │ H3BIk  │
# │ 2   │ 0.396882  │ 5     │ Rv2SB  │
# │ 3   │ 0.797529  │ 5     │ M61Hw  │
# │ 4   │ 0.856915  │ 5     │ jLc7K  │
# │ 5   │ 0.0120147 │ 1     │ HgZMA  │
# │ 6   │ 0.493593  │ 3     │ ENfu3  │
# │ 7   │ 0.27618   │ 2     │ MIU5B  │
# │ 8   │ 0.492329  │ 10    │ QflU7  │
# │ 9   │ 0.398613  │ 10    │ 4XioP  │
# │ 10  │ 0.40273   │ 10    │ PQs14  │</code></pre><h3 id="Working-with-comressed-CSV-1"><a class="docs-heading-anchor" href="#Working-with-comressed-CSV-1">Working with comressed CSV</a><a class="docs-heading-anchor-permalink" href="#Working-with-comressed-CSV-1" title="Permalink"></a></h3><p>Since csv can be rather large it&#39;s a common practice to compress it before uploading. It can be done as follows (assuming the same <code>df</code> from the previous example)</p><pre><code class="language-julia">using CodecZlib

buf = CSV.write(IOBuffer(), df) |&gt; seekstart |&gt; GzipCompressorStream
res = uploadfile(client, files = &quot;data.csv.gz&quot; =&gt; buf)</code></pre><p>Note that we should use <code>seekstart</code> here, since after <code>IOBuffer</code> is written, it&#39;s pointer located at the end and subsequent reading of the buffer in <code>uploadfile</code> return empty array. Also, in this exampe we used <code>GzipCompressorStream</code>, but any other compressing algorithm can be used, refer <a href="https://github.com/JuliaIO/TranscodingStreams.jl#codec-packages">TranscodingStreams.jl</a>.</p><p>And to verify the result of upload</p><pre><code class="language-julia">using UrlDownload
using Underscores

df2 = @_ getfilelink(client, fileid = first(res.fileids)) |&gt; 
   urldownload(&quot;https://&quot; * first(__.hosts) * __.path) |&gt; DataFrame 
# 10×3 DataFrame
# │ Row │ x         │ y     │ z      │
# │     │ Float64   │ Int64 │ String │
# ├─────┼───────────┼───────┼────────┤
# │ 1   │ 0.0756344 │ 6     │ H3BIk  │
# │ 2   │ 0.396882  │ 5     │ Rv2SB  │
# │ 3   │ 0.797529  │ 5     │ M61Hw  │
# │ 4   │ 0.856915  │ 5     │ jLc7K  │
# │ 5   │ 0.0120147 │ 1     │ HgZMA  │
# │ 6   │ 0.493593  │ 3     │ ENfu3  │
# │ 7   │ 0.27618   │ 2     │ MIU5B  │
# │ 8   │ 0.492329  │ 10    │ QflU7  │
# │ 9   │ 0.398613  │ 10    │ 4XioP  │
# │ 10  │ 0.40273   │ 10    │ PQs14  │</code></pre><h2 id="Uploading-generated-image-1"><a class="docs-heading-anchor" href="#Uploading-generated-image-1">Uploading generated image</a><a class="docs-heading-anchor-permalink" href="#Uploading-generated-image-1" title="Permalink"></a></h2><p>In this example we will use <a href="https://github.com/JuliaGraphics/Luxor.jl">Luxor.jl</a> for image generation and also use <code>getfilepublink</code> to generate public link to the resulting image.</p><pre><code class="language-julia">using Luxor

d = Drawing(600, 400, :png)
origin()
background(&quot;white&quot;)
for θ in range(0, step=π/8, length=16)
    gsave()
    scale(0.25)
    rotate(θ)
    translate(250, 0)
    randomhue()
    julialogo(action=:fill, color=false)
    grestore()
end

gsave()
scale(0.3)
juliacircles()
grestore()

translate(200, -150)
scale(0.3)
julialogo()
finish()</code></pre><p>Please notice, that we used <code>:png</code> keyword in <code>Drawing</code> definition, to force in-memory image processing.</p><pre><code class="language-julia">using PCloud
using PCloud: uploadfile, getfilepublink

token = # HERE SHOULD BE YOUR TOKEN
client = PCloudClient(auth_token = token)

res = uploadfile(client, files = &quot;logo.png&quot; =&gt; d.buffer)

getfilepublink(client, fileid = first(res.fileids)).link
# &quot;https://u.pcloud.link/publink/show?code=XZh8FEkZ6vBed7DI1Wys8g7BHl8FFVuhUSSX&quot;</code></pre><p>If you follow this <a href="https://u.pcloud.link/publink/show?code=XZh8FEkZ6vBed7DI1Wys8g7BHl8FFVuhUSSX">link</a>, you can see that it is valid png file.</p><h2 id="Project-Gutenberg-and-downloadfile-1"><a class="docs-heading-anchor" href="#Project-Gutenberg-and-downloadfile-1">Project Gutenberg and <code>downloadfile</code></a><a class="docs-heading-anchor-permalink" href="#Project-Gutenberg-and-downloadfile-1" title="Permalink"></a></h2><p>Method <a href="@ref"><code>PCloud.downloadfile</code></a> can download file from urls directly to pCloud. This can be very useful during web crawling, when various information of interest should be saved for further investigation. As an example we download 10 top books from <a href="https://www.gutenberg.org/">Project Gutenberg</a></p><pre><code class="language-julia">using Underscores
using Gumbo
using Cascadia
using Cascadia: matchFirst
using UrlDownload
using PCloud
using PCloud: createfolder, downloadfile

token = # HERE SHOULD BE YOUR TOKEN
client = PCloudClient(auth_token = token)

# folder where books will be stored
folderid = createfolder(client, folderid = 0, name = &quot;Gutenberg&quot;).metadata.folderid

host = &quot;https://www.gutenberg.org&quot;

# helper function for parsing data downloaded by `urldownload` to a more useful format
pageparser(x) = parsehtml(String(x)).root

# helper function which finds download url on each book page
# should be used for parsing each individual book page, for example
# getlink(&quot;https://www.gutenberg.org/ebooks/1342&quot;) would produce url to
# &quot;Pride and Prejudice&quot; in epub format.
getlink(url) = @_ urldownload(url, parser = pageparser) |&gt;
    host*matchFirst(sel&quot;a[type=&#39;application/epub+zip&#39;]&quot;, __).attributes[&quot;href&quot;]
    
# This is central function, which parses top scores page, extract top 10 books,
# extract download url for each book with the help of `getlink` and finally
# download everything to pCloud
@_ urldownload(&quot;https://www.gutenberg.org/browse/scores/top&quot;, parser = pageparser) |&gt;
    matchFirst(sel&quot;ol&quot;, __) |&gt; eachmatch(sel&quot;li&quot;, __)[1:10] |&gt;
    matchFirst.(Ref(sel&quot;a&quot;), __) |&gt; map(host*_.attributes[&quot;href&quot;], __) |&gt;
    getlink.(__) |&gt; join(__, &quot; &quot;) |&gt;
    downloadfile(client, url = __, folderid = folderid)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference/">« Reference API</a><a class="docs-footer-nextpage" href="../developers/">Deveopers guide »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 June 2020 09:23">Tuesday 9 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
